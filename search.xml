<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog的初次暴走</title>
    <url>/2025/08/02/Blog%E7%9A%84%E5%88%9D%E6%AC%A1%E6%9A%B4%E8%B5%B0/</url>
    <content><![CDATA[<p>昨天 BlogWeb 暴走了，主要是因为凌晨三点加的那段动态天气代码里藏了个没闭合的循环。原本想让天气图标每小时自动刷新，结果写成了while(true)却忘了加终止条件，代码像脱缰的野马在后台疯狂请求接口。等早上发现时，服务器日志已经堆到了 300 多 MB，全是重复的天气数据报错，连带着首页加载时都在疯狂弹窗 —— 毕竟每秒钟弹出十几次 “获取天气失败” 的提示，再稳的浏览器也扛不住。<br>更糟的是，因为循环占用了太多进程，连后台管理页面都卡成了幻灯片。点 “编辑文章” 要等三分钟才能加载出编辑器，好不容易改完内容点保存，直接弹出 404 超时。最哭笑不得的是，原本用来美化页面的粒子特效插件，因为内存被占满，粒子全黏成了一团黑乎乎的像素块，在屏幕上像只乱爬的虫子。<br>后来对着服务器监控日志一点点捋，才发现问题根源藏在sidebar.njk的脚本里。删那行循环代码时手都在抖，生怕误删了其他功能。重启服务器后看着控制台跳出 “正常运行” 的提示，突然觉得那些凌晨改代码的冲动，都不如加个定时器再睡个好觉实在。现在每次改代码都逼着自己先写注释，哪怕只是加一行打印，也得标清楚 “这里可能会炸”—— 毕竟谁也不想再体验一次，看着自己的博客从精致小站变成狂弹窗的 “失控现场” 了。</p>
<p>特别感谢：LCX（Thank you for your support）</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>Note</tag>
        <tag>观测</tag>
      </tags>
  </entry>
  <entry>
    <title>对我和你或许有帮助的一次讲解（Day 1）</title>
    <url>/2025/08/28/Day%201/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我这里的时间已经是深更半夜了，听着戳的-My My My！-身为一位合格的需动机主义者，突觉这几天没有学习C++，再看看20几天后又要比赛了….我</p>
<p>认为我需要做出一点的Action，于是我打算以自我讲解的方式，梳理一下我最近学习的C++知识。</p>
<p>当然我会从基础开始，逐步讲解，希望能让大家都能理解。……^-^</p>
<span id="more"></span>

<p>好的，我们开始！我会用最简单直接的方式，让你在30分钟内掌握这些C++基础。</p>
<h3 id="1-输入-cin-和输出-cout"><a href="#1-输入-cin-和输出-cout" class="headerlink" title="1. 输入(cin)和输出(cout)"></a>1. 输入(cin)和输出(cout)</h3><p>首先，你需要包含头文件 <iostream> 并使用 std 命名空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout 用于输出 (console out)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl; <span class="comment">// endl 表示换行</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl; <span class="comment">// 可以混合输出文本和变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cin 用于输入 (console in)</span></span><br><span class="line">    <span class="type">int</span> inputNumber;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter a number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; inputNumber; <span class="comment">// 程序会暂停，等待你输入一个数字</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; inputNumber &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;&lt; 是输出操作符，可以链式使用 (cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;)</span><br><span class="line"></span><br><span class="line">&gt;&gt; 是输入操作符，可以链式使用 (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;)</span><br><span class="line"></span><br><span class="line">endl 用来换行，也可以用 <span class="string">&quot;\n&quot;</span> 代替，如 cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型	描述	示例	大致范围</span><br><span class="line"><span class="type">int</span>	整数	<span class="type">int</span> count = <span class="number">10</span>;	<span class="number">-2</span>×<span class="number">10</span>⁹ 到 <span class="number">2</span>×<span class="number">10</span>⁹</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>	超大的整数	<span class="type">long</span> <span class="type">long</span> bigNum = <span class="number">123456789012345LL</span>;	<span class="number">-9</span>×<span class="number">10</span>¹⁸ 到 <span class="number">9</span>×<span class="number">10</span>¹⁸</span><br><span class="line"><span class="type">double</span>	双精度浮点数（小数）	<span class="type">double</span> price = <span class="number">9.99</span>;	精度约<span class="number">15</span>位小数</span><br><span class="line"><span class="type">char</span>	单个字符	<span class="type">char</span> grade = <span class="string">&#x27;A&#x27;</span>;	单个字母/符号</span><br><span class="line">string	字符串（需<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>）	string name = <span class="string">&quot;Alice&quot;</span>;	一串文本</span></span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// 使用string类型需要包含这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> apples = <span class="number">5</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> starsInGalaxy = <span class="number">1000000000000LL</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">char</span> firstLetter = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    string language = <span class="string">&quot;C++&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Apples: &quot;</span> &lt;&lt; apples &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stars: &quot;</span> &lt;&lt; starsInGalaxy &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First Letter: &quot;</span> &lt;&lt; firstLetter &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Language: &quot;</span> &lt;&lt; language &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要点：-1"><a href="#要点：-1" class="headerlink" title="要点："></a>要点：</h4><p>给 long long 变量赋值时，数字后面加 LL 是个好习惯。</p>
<p>char 用单引号 ‘’，string 用双引号 “”。</p>
<h3 id="3-循环-for-while-和判断-if-else"><a href="#3-循环-for-while-和判断-if-else" class="headerlink" title="3. 循环 (for&#x2F;while) 和判断 (if&#x2F;else)"></a>3. 循环 (for&#x2F;while) 和判断 (if&#x2F;else)</h3><h4 id="if-else-判断"><a href="#if-else-判断" class="headerlink" title="if&#x2F;else 判断"></a>if&#x2F;else 判断</h4><p>根据条件执行不同的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your score: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123; <span class="comment">// 如果条件成立</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Grade: A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123; <span class="comment">// 如果上一个条件不成立，检查这个</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Grade: Pass&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果所有条件都不成立</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Grade: Fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>当你明确知道要循环多少次时使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环10次，i从0到9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i is: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1到100的和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">100</span>; num++) &#123;</span><br><span class="line">        sum += num; <span class="comment">// 等价于 sum = sum + num;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum from 1 to 100 is: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for循环结构：-for-初始化-循环条件-更新-循环体"><a href="#for循环结构：-for-初始化-循环条件-更新-循环体" class="headerlink" title="for循环结构： for (初始化; 循环条件; 更新) { 循环体 }"></a>for循环结构： for (初始化; 循环条件; 更新) { 循环体 }</h4><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>当你不确定要循环多少次，但知道循环条件时使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while循环：当条件满足时，一直循环</span></span><br><span class="line">    <span class="keyword">while</span> (number &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        cout &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        number *= <span class="number">2</span>; <span class="comment">// number = number * 2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do-while循环：先执行一次，再判断条件</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter a positive number: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x &lt;= <span class="number">0</span>); <span class="comment">// 如果输入的数字不大于0，就继续循环要求输入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while循环结构：-while-循环条件-循环体"><a href="#while循环结构：-while-循环条件-循环体" class="headerlink" title="while循环结构： while (循环条件) { 循环体 }"></a>while循环结构： while (循环条件) { 循环体 }</h4><p>综合练习<br>我们来写一个程序，综合运用以上所有知识：判断一个数是否为素数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a positive integer: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理一些简单情况</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; is not a prime number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设它是素数</span></span><br><span class="line">    <span class="type">bool</span> isPrime = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查从2到n-1，是否有能整除n的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; <span class="comment">// 如果n能被i整除</span></span><br><span class="line">            isPrime = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 发现一个因子就不是素数，立即跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPrime) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; is a prime number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; is not a prime number.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核心要点总结"><a href="#核心要点总结" class="headerlink" title="核心要点总结"></a>核心要点总结</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cin/cout: cin &gt;&gt; variable; cout &lt;&lt; <span class="string">&quot;Text&quot;</span> &lt;&lt; variable &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型:"></a>数据类型:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">整数用 <span class="type">int</span>，很大用 <span class="type">long</span> <span class="type">long</span></span><br><span class="line"></span><br><span class="line">小数用 <span class="type">double</span></span><br><span class="line"></span><br><span class="line">单个字符用 <span class="type">char</span>，字符串用 <span class="built_in">string</span> (要 <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>/<span class="keyword">else</span>: 根据条件选择执行路径。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环: <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)，用于已知次数的循环。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>循环: <span class="keyword">while</span> (condition)，用于满足条件时的循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最后建议：-打开你的代码编辑器，把上面的例子都亲手敲一遍并运行。这是最快最有效的学习方式！30分钟到了，但你还需要多练习来巩固。加油！"><a href="#最后建议：-打开你的代码编辑器，把上面的例子都亲手敲一遍并运行。这是最快最有效的学习方式！30分钟到了，但你还需要多练习来巩固。加油！" class="headerlink" title="最后建议： 打开你的代码编辑器，把上面的例子都亲手敲一遍并运行。这是最快最有效的学习方式！30分钟到了，但你还需要多练习来巩固。加油！"></a>最后建议： 打开你的代码编辑器，把上面的例子都亲手敲一遍并运行。这是最快最有效的学习方式！30分钟到了，但你还需要多练习来巩固。加油！</h4>]]></content>
      <categories>
        <category>study</category>
        <category>氢氧根</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Espresso</title>
    <url>/2025/08/04/Espresso/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1954627753&bvid=BV1ay411Y7WS&cid=1549402671&p=1" 
        width="100%" height="450" frameborder="0" scrolling="no" allowfullscreen="true"></iframe>
]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>Horse Races</title>
    <url>/2025/08/06/Horse%20Races%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="我们先看题"><a href="#我们先看题" class="headerlink" title="我们先看题"></a>我们先看题</h4><h1 id="CF95D-Horse-Races"><a href="#CF95D-Horse-Races" class="headerlink" title="CF95D Horse Races"></a>CF95D Horse Races</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Petya likes horse racing very much. Horses numbered from $ l $ to $ r $ take part in the races. Petya wants to evaluate the probability of victory; for some reason, to do that he needs to know the amount of nearly lucky horses’ numbers. A nearly lucky number is an integer number that has at least two lucky digits the distance between which does not exceed $ k $ . Petya learned from some of his mates from Lviv that lucky digits are digits $ 4 $ and $ 7 $ . The distance between the digits is the absolute difference between their positions in the number of a horse. For example, if $ k&#x3D;2 $ , then numbers $ 412395497 $ , $ 404 $ , $ 4070400000070004007 $ are nearly lucky and numbers $ 4 $ , $ 4123954997 $ , $ 4007000040070004007 $ are not.</p>
<p>Petya prepared $ t $ intervals $ [l_{i},r_{i}] $ and invented number $ k $ , common for all of them. Your task is to find how many nearly happy numbers there are in each of these segments. Since the answers can be quite large, output them modulo $ 1000000007 $ ( $ 10^{9}+7 $ ).</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains two integers $ t $ and $ k $ ( $ 1&lt;&#x3D;t,k&lt;&#x3D;1000 $ ) — the number of segments and the distance between the numbers correspondingly. Next $ t $ lines contain pairs of integers $ l_{i} $ and $ r_{i} $ ( $ 1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;10^{1000} $ ). All numbers are given without the leading zeroes. Numbers in each line are separated by exactly one space character.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Output $ t $ lines. In each line print one integer — the answer for the corresponding segment modulo $ 1000000007 $ ( $ 10^{9}+7 $ ).</p>
<h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure>

<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例 #2"></a>输入输出样例 #2</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入 #2"></a>输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">70 77</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出 #2"></a>输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="输入输出样例-3"><a href="#输入输出样例-3" class="headerlink" title="输入输出样例 #3"></a>输入输出样例 #3</h2><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入 #3"></a>输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 20</span><br><span class="line">80 100</span><br></pre></td></tr></table></figure>

<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出 #3"></a>输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>In the first sample, the four nearly lucky numbers are 44, 47, 74, 77.</p>
<p>In the second sample, only 74 and 77 are in the given segment.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道比较基础的数位DP。</p>
<p>答案明显可以差分出来，ans&#x3D;calc(r)−calc(l−1) ，但是由于数据范围太大 1≤l≤r≤10的1000次方，所以我们必须将 l 单独拿出来判断一下。</p>
<p>至于 calc(x) ，可以用数位dp来进行求解，定义 dp i,j,k<br>​<br>  为在第 i 位距上一个幸运数字距离为 j 且是否满足条件的数的数量。</p>
<p>状态转移的过程可以用记忆化搜索来实现。之后就可以很简单的解决了。</p>
<p>Code (最近学坏了，压行的有些厉害)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> bits[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> t,k;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> len,<span class="type">int</span> lpos,<span class="type">int</span> fg,<span class="type">bool</span> border)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!len) <span class="keyword">return</span> fg == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!border &amp;&amp; dp[len][lpos][fg]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[len][lpos][fg];</span><br><span class="line">    <span class="type">int</span> up=border? bits[len]:<span class="number">9</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">4</span>||i==<span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">dfs</span>(len<span class="number">-1</span>,len,(lpos &amp;&amp; lpos-len&lt;=k)|fg,border&amp;&amp;i==up);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res += <span class="built_in">dfs</span>(len - <span class="number">1</span>, lpos, fg, border &amp;&amp; i == up);</span><br><span class="line">    &#125;</span><br><span class="line">    res %= mod;</span><br><span class="line">    <span class="keyword">if</span>(!border) dp[len][lpos][fg] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">f</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        bits[++ len] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i<span class="number">-1</span>]==<span class="string">&#x27;4&#x27;</span>||s[i<span class="number">-1</span>]==<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p||i-p&gt;k) p=i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-p&lt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;k;</span><br><span class="line">    string l,r;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans=<span class="built_in">f</span>(r)-<span class="built_in">f</span>(l)+(<span class="built_in">check</span>(l)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;(ans%mod+mod)%mod&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>study</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Link Cut Tree 学习笔记</title>
    <url>/2025/08/04/Link-Cut-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Link Cut Tree（简称 LCT）是使用 Splay 和实链剖分来维护森林的一个数据结构，它支持以下在线操作：</p>
<ul>
<li>查询 &#x2F; 修改链上的信息</li>
<li>换根</li>
<li>动态连边 &#x2F; 删边</li>
<li>查询连通性</li>
<li>……</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在 LCT 中，每个 Splay 维护的是一条从上到下且深度<strong>严格</strong>递增的实链，且 Splay 按照点的深度排序。</p>
<p>不同于重链剖分，实链剖分选择的实儿子由我们自己决定。</p>
<p><img src="https://github.com/Early0v0/Blog/blob/master/source/_posts/Link-Cut-Tree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/eg.png?raw=true" alt="eg"></p>
<span id="more"></span>

<p>比如这棵树，我们如果选择 $2,5$ 做实儿子，则实链有 ${1,2,5},{3},{4}$；如果选择 $3,4$ 做实儿子，则实链有 ${1,3},{2,4},{5}$。</p>
<p>实链剖分具有灵活的特性，可以方便地维护动态问题。</p>
<p>对于每条实链，我们为它创建一个 Splay 来维护。</p>
<p>它有以下性质：</p>
<ol>
<li>每个节点被有且仅有一个 Splay 包含；</li>
<li>边分为实边和虚边，实边的两个端点在同一个 Splay 中，虚边则是从一个 Splay 中深度最低的节点指向另一个 Splay。</li>
</ol>
<p>为了保持 Splay 的二叉树形状，我们让节点不指向虚儿子，只让儿子指向它（即“认父不认子”）。</p>
<h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>用 struct 和指针存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> val,sum;</span><br><span class="line">    <span class="type">bool</span> rev;</span><br><span class="line">    tree *fa,*son[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line">tree nul&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,&amp;nul,&#123;&amp;nul,&amp;nul&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="更新子树信息"><a href="#更新子树信息" class="headerlink" title="更新子树信息"></a>更新子树信息</h4><p><a href="https://www.luogu.com.cn/problem/P3690">洛谷例题</a>要求维护的是异或和，所以代码中亦是如此。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x-&gt;sum=x-&gt;val^x-&gt;son[<span class="number">0</span>]-&gt;sum^x-&gt;son[<span class="number">1</span>]-&gt;sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否为-Splay-的根"><a href="#判断是否为-Splay-的根" class="headerlink" title="判断是否为 Splay 的根"></a>判断是否为 Splay 的根</h4><p>根据“认父不认子”，如果 $X$ 不是其父亲的左 &#x2F; 右儿子，则它就是当前 Splay 的根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_root</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x!=x-&gt;fa-&gt;son[<span class="number">0</span>])&amp;&amp;(x!=x-&gt;fa-&gt;son[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断儿子类型"><a href="#判断儿子类型" class="headerlink" title="判断儿子类型"></a>判断儿子类型</h4><p>与 Splay 的思想一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">son_type</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==x-&gt;fa-&gt;son[<span class="number">0</span>]?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间翻转"><a href="#区间翻转" class="headerlink" title="区间翻转"></a>区间翻转</h4><p>与 Splay 翻转的思想一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x-&gt;rev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;son[<span class="number">0</span>]-&gt;rev^=<span class="number">1</span>,x-&gt;son[<span class="number">1</span>]-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">swap</span>(x-&gt;son[<span class="number">0</span>],x-&gt;son[<span class="number">1</span>]);</span><br><span class="line">    x-&gt;rev=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Update-操作"><a href="#Update-操作" class="headerlink" title="Update 操作"></a>Update 操作</h4><p>将 $X$ 到根的所有节点 Push_down。</p>
<p>可用递归实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">is_root</span>(x)) &#123;</span><br><span class="line">        <span class="built_in">update</span>(x-&gt;fa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上旋"><a href="#上旋" class="headerlink" title="上旋"></a>上旋</h4><p>如果当前节点的父亲是 Splay 的根则需特判。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *fa=x-&gt;fa,*ffa=fa-&gt;fa;</span><br><span class="line">    <span class="type">int</span> typ=<span class="built_in">son_type</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">is_root</span>(fa)) &#123;</span><br><span class="line">        ffa-&gt;son[<span class="built_in">son_type</span>(fa)]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    fa-&gt;son[typ]=x-&gt;son[typ^<span class="number">1</span>],x-&gt;son[typ^<span class="number">1</span>]-&gt;fa=fa;</span><br><span class="line">    x-&gt;son[typ^<span class="number">1</span>]=fa,fa-&gt;fa=x;</span><br><span class="line">    x-&gt;fa=ffa;</span><br><span class="line">    <span class="built_in">push_up</span>(fa),<span class="built_in">push_up</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Splay-操作"><a href="#Splay-操作" class="headerlink" title="Splay 操作"></a>Splay 操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(tree *fa;fa=x-&gt;fa,!<span class="built_in">is_root</span>(x);<span class="built_in">rotate</span>(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">is_root</span>(fa)) &#123;</span><br><span class="line">            <span class="built_in">rotate</span>(<span class="built_in">son_type</span>(x)==<span class="built_in">son_type</span>(fa)?fa:x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_up</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Access-操作"><a href="#Access-操作" class="headerlink" title="Access 操作"></a>Access 操作</h3><p>将根节点到某个节点的所有边变为实边，并且将它的儿子全部设为虚儿子。</p>
<p>我们从 $X$ 出发，将其 Splay 到当前 Splay 树的根，然后将它的右儿子设置为空（即断开它与它的实儿子）。</p>
<p>然后我们跳到 $X$ 的父节点 $Fa$，同样将其 Splay 到根，然后将它的右儿子设置为 $X$。</p>
<p>循环处理，直到跳到树根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(tree *ori=&amp;nul;x!=&amp;nul;ori=x,x=x-&gt;fa) &#123;</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        x-&gt;son[<span class="number">1</span>]=ori;</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="换根"><a href="#换根" class="headerlink" title="换根"></a>换根</h3><p>让指定点成为<strong>原树</strong>的根。</p>
<p>首先对 $X$ 进行 Access，此时 $X$ 一定为 Splay 树中深度最大的点。</p>
<blockquote>
<p>原因：Access 将它的儿子全部设为虚儿子。</p>
</blockquote>
<p>然后我们将 $X$ 进行 Splay，此时它就没有了右子树且成为了根节点。</p>
<p>最后将 $X$ 的翻转标记异或 $1$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_root</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    x-&gt;rev^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找根"><a href="#找根" class="headerlink" title="找根"></a>找根</h3><p>寻找 $X$ 所在<strong>原树</strong>的根。</p>
<p>与换根类似，首先对 $X$ 进行 Access，然后我们将 $X$ 进行 Splay，沿途 Push_down 并一路向左找即可（根的深度最浅）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tree *<span class="title">find_root</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">push_down</span>(x),x-&gt;son[<span class="number">0</span>]!=&amp;nul) &#123;</span><br><span class="line">        x=x-&gt;son[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问原树的链"><a href="#访问原树的链" class="headerlink" title="访问原树的链"></a>访问原树的链</h3><p>需保证 $X,Y$ 连通。</p>
<p>先将 $X$ 设为根，然后对 $Y$ 进行 Access 与 Splay，此时 $Y$ 上就维护了从 $X$ 到 $Y$ 的链上的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(tree *x,tree *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">make_root</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">    <span class="built_in">splay</span>(y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然我很好奇为什么它叫 Split（分裂）。</p>
</blockquote>
<blockquote>
<p>终于到了 LCT 的 Link 和 Cut 了！:tada:</p>
</blockquote>
<h3 id="连边"><a href="#连边" class="headerlink" title="连边"></a>连边</h3><p>使 $X$ 成为根，如果 $X,Y$ 不连通则将 $X$ 的父亲指向 $Y$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(tree *x,tree *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">make_root</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find_root</span>(y)!=x) &#123;</span><br><span class="line">        x-&gt;fa=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="断边"><a href="#断边" class="headerlink" title="断边"></a>断边</h3><p>使 $X$ 成为根，如果 $X,Y$ <strong>直接</strong>连通则双向断开关系。</p>
<p>不要忘了更新 $X$ 维护的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(tree *x,tree *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">make_root</span>(x);</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">find_root</span>(y)==x)&amp;&amp;(y-&gt;fa==x)) &#123;</span><br><span class="line">        x-&gt;son[<span class="number">1</span>]=y-&gt;fa=&amp;nul;</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><blockquote>
<p>本文部分参考 <a href="https://www.cnblogs.com/flashhu/p/8324551.html">LCT 总结 - Flash_Hu</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>study</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>NEWNEW</title>
    <url>/2025/08/06/New/</url>
    <content><![CDATA[<h1 id="NEWNEW"><a href="#NEWNEW" class="headerlink" title="NEWNEW"></a>NEWNEW</h1><p><img src="https://static-cse.canva.cn/blob/234749/.gif" alt="NEWNEW"></p>
]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>GIF</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay 学习笔记</title>
    <url>/2025/08/03/Splay-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Splay 是二叉查找树的一种，它通过访问节点时将其旋转到根节点，使查找树尽量维持平衡。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每个节点需保存它所维护的值 $val$，这个值所出现的次数 $cnt$，它的子树大小 $size$，它的父节点 $fa$ 以及它的左儿子 $son_0$ 和右儿子 $son_1$。</p>
<blockquote>
<p>说明：代码中 $t$ 即 $&amp;t[0]$，是定义的一个空节点，其 $val,cnt,siz$ 均为 $0$，父亲和儿子都指向自己。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">splay_tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> val,cnt,siz;</span><br><span class="line">    splay_tree *fa,*son[<span class="number">2</span>];</span><br><span class="line">&#125;t[N<span class="number">+1</span>],*root;</span><br></pre></td></tr></table></figure>

<h3 id="更新子树大小"><a href="#更新子树大小" class="headerlink" title="更新子树大小"></a>更新子树大小</h3><p>节点改变后更新它的 $siz$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maintain</span><span class="params">(splay_tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x-&gt;siz=x-&gt;cnt+x-&gt;son[<span class="number">0</span>]-&gt;siz+x-&gt;son[<span class="number">1</span>]-&gt;siz;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁节点"><a href="#销毁节点" class="headerlink" title="销毁节点"></a>销毁节点</h3><p>前提是已经将它移至叶子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(splay_tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x-&gt;val=x-&gt;cnt=x-&gt;siz=<span class="number">0</span>;</span><br><span class="line">    x-&gt;fa=x-&gt;son[<span class="number">0</span>]=x-&gt;son[<span class="number">1</span>]=t;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上旋"><a href="#上旋" class="headerlink" title="上旋"></a>上旋</h3><p>本质上是将一个节点上移一个位置。</p>
<p>上旋分为两种：左儿子上旋为右旋，右儿子上旋为左旋。</p>
<p><img src="https://github.com/Early0v0/Blog/blob/master/source/_posts/Splay-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rotate.png?raw=true" alt="右旋前 右旋后"></p>
<p>步骤如下（以右旋为例）：</p>
<ol>
<li>将 $Fa$ 的左儿子指向 $Xson2$，$Xson2$ 的父亲指向 $Fa$；</li>
<li>将 $X$ 的右儿子指向 $Fa$，$Fa$ 的父亲指向 $X$；</li>
<li>如果 $Fa$ 有父亲（记为 $FFa$），则将 $X$ 的父亲指向 $FFa$，$FFa$ 的儿子（原来 $Fa$ 所在位置）指向 $X$；</li>
<li>更新 $X$ 和 $Fa$ 的 $siz$ 值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(splay_tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    splay_tree *fa=x-&gt;fa,*ffa=fa-&gt;fa;</span><br><span class="line">    <span class="type">int</span> ch=x==x-&gt;fa-&gt;son[<span class="number">0</span>]?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">    fa-&gt;son[ch]=x-&gt;son[ch^<span class="number">1</span>],x-&gt;son[ch^<span class="number">1</span>]-&gt;fa=fa;</span><br><span class="line">    x-&gt;son[ch^<span class="number">1</span>]=fa,fa-&gt;fa=x,x-&gt;fa=ffa;</span><br><span class="line">    <span class="keyword">if</span>(ffa!=t) &#123;</span><br><span class="line">        ffa-&gt;son[fa==ffa-&gt;son[<span class="number">0</span>]?<span class="number">0</span>:<span class="number">1</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">maintain</span>(fa),<span class="built_in">maintain</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Splay-操作"><a href="#Splay-操作" class="headerlink" title="Splay 操作"></a>Splay 操作</h3><p>将访问的节点旋转到根节点。</p>
<ul>
<li>如果 $X$ 的父亲是根节点，直接将 $X$ 上旋，结束操作；</li>
<li>如果 $X$ 与其父亲儿子类型相同，先上旋其父亲，再上旋 $X$；</li>
<li>否则连续上旋两次 $X$。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(splay_tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(splay_tree *fa=x-&gt;fa;fa=x-&gt;fa,fa!=t;<span class="built_in">rotate</span>(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa-&gt;fa!=t) &#123;</span><br><span class="line">            <span class="built_in">rotate</span>((x==fa-&gt;son[<span class="number">0</span>])==(fa==fa-&gt;fa-&gt;son[<span class="number">0</span>])?fa:x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root=x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立-Splay"><a href="#建立-Splay" class="headerlink" title="建立 Splay"></a>建立 Splay</h3><p>先将数据升序排序（假设需要插入 $a$ 数组），然后用类似建立线段树的方法递归建立。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">splay_tree *<span class="title">build</span><span class="params">(splay_tree *fa,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    splay_tree *x=&amp;(t[++tot]=splay_tree&#123;a[mid],<span class="number">1</span>,<span class="number">0</span>,fa,&#123;t,t&#125;&#125;);</span><br><span class="line">    x-&gt;son[<span class="number">0</span>]=<span class="built_in">build</span>(x,l,mid<span class="number">-1</span>),x-&gt;son[<span class="number">1</span>]=<span class="built_in">build</span>(x,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">maintain</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入值"><a href="#插入值" class="headerlink" title="插入值"></a>插入值</h3><ul>
<li>如果树为空，则新建根节点并插入，结束操作；</li>
<li>否则由根开始遍历：<ul>
<li>如果当前节点的权值等于 $val$，则当前节点的 $cnt$ 值 +1，更新节点和父亲的 $siz$ ，并对当前节点进行 Splay 操作；</li>
<li>如果当前节点为空，则在此新建节点即可；</li>
<li>否则按照二叉查找树的性质向下递归。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==t) &#123;</span><br><span class="line">        t[++tot]=splay_tree&#123;val,<span class="number">1</span>,<span class="number">1</span>,t,&#123;t,t&#125;&#125;;</span><br><span class="line">        root=&amp;t[tot];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    splay_tree *x=root,*fa=t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;val==val) &#123;</span><br><span class="line">            ++x-&gt;cnt;</span><br><span class="line">            <span class="built_in">maintain</span>(x),<span class="built_in">maintain</span>(fa);</span><br><span class="line">            <span class="built_in">splay</span>(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa=x,x=x-&gt;son[x-&gt;val&lt;val];</span><br><span class="line">        <span class="keyword">if</span>(x==t) &#123;</span><br><span class="line">            t[++tot]=splay_tree&#123;val,<span class="number">1</span>,<span class="number">1</span>,fa,&#123;t,t&#125;&#125;;</span><br><span class="line">            fa-&gt;son[val&gt;fa-&gt;val]=&amp;t[tot];</span><br><span class="line">            <span class="built_in">maintain</span>(&amp;t[tot]),<span class="built_in">maintain</span>(fa);</span><br><span class="line">            <span class="built_in">splay</span>(&amp;t[tot]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-val-的排名"><a href="#查询-val-的排名" class="headerlink" title="查询 val 的排名"></a>查询 val 的排名</h3><ul>
<li>初始排名为 $1$；</li>
<li>如果 $val$ 比当前节点的权值小，则递归左子树；</li>
<li>如果 $val$ 比当前节点的权值大，则将答案加上左子树的 $siz$ 和当前节点的 $cnt$，递归右子树；</li>
<li>如果 $val$ 等于当前节点的权值，返回答案；</li>
<li>最后进行 Splay 操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">val2rank</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">    splay_tree *x=root;</span><br><span class="line">    <span class="keyword">while</span>(x!=t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;x-&gt;val) &#123;</span><br><span class="line">            x=x-&gt;son[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret+=x-&gt;son[<span class="number">0</span>]-&gt;siz;</span><br><span class="line">            <span class="keyword">if</span>(val==x-&gt;val) &#123;</span><br><span class="line">                <span class="built_in">splay</span>(x);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret+=x-&gt;cnt;</span><br><span class="line">            x=x-&gt;son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询排名为-rnk-的数"><a href="#查询排名为-rnk-的数" class="headerlink" title="查询排名为 rnk 的数"></a>查询排名为 rnk 的数</h3><ul>
<li><p>如果 $rnk$ 小于等于当前节点左子树的 $siz$，则递归左子树；</p>
</li>
<li><p>否则将 $rnk$ 减去左子树的 $siz$ 和当前节点的 $cnt$，如果 $rnk\leq0$，则返回当前节点的权值，否则递归右子树。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank2val</span><span class="params">(<span class="type">int</span> rnk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    splay_tree *x=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((x-&gt;son[<span class="number">0</span>]!=t)&amp;&amp;(rnk&lt;=x-&gt;son[<span class="number">0</span>]-&gt;siz)) &#123;</span><br><span class="line">            x=x-&gt;son[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rnk-=x-&gt;son[<span class="number">0</span>]-&gt;siz+x-&gt;cnt;</span><br><span class="line">            <span class="keyword">if</span>(rnk&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> x-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            x=x-&gt;son[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除值"><a href="#删除值" class="headerlink" title="删除值"></a>删除值</h3><ul>
<li>先找到值为 $val$ 的节点，将其进行 Splay 操作（可以通过查询 $val$ 的排名实现）；</li>
<li>如果它的 $cnt$ 值大于 $1$，则令 $cnt\gets cnt-1$ 即可；</li>
<li>如果它是唯一的节点，则直接删除节点；</li>
<li>如果它只有一个儿子，则令它的儿子作根，然后删除节点；</li>
<li>否则找到值小于 $val$ 的最大节点进行 Splay 操作，令根的右子树为值为 $val$ 的节点的右子树，更新根的 $siz$，最后删除节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">val2rank</span>(val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;cnt&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        --root-&gt;cnt,--root-&gt;siz;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((root-&gt;son[<span class="number">0</span>]==t)&amp;&amp;(root-&gt;son[<span class="number">1</span>]==t)) &#123;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">        root=t;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;son[i]!=t) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        splay_tree *x=root;</span><br><span class="line">        root=root-&gt;son[i^<span class="number">1</span>];</span><br><span class="line">        root-&gt;fa=t;</span><br><span class="line">        <span class="built_in">clear</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    splay_tree *x=root-&gt;son[<span class="number">0</span>],*rt=root;</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;son[<span class="number">1</span>]!=t) &#123;</span><br><span class="line">        x=x-&gt;son[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    rt-&gt;son[<span class="number">1</span>]-&gt;fa=x,x-&gt;son[<span class="number">1</span>]=rt-&gt;son[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">clear</span>(rt);</span><br><span class="line">    <span class="built_in">maintain</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-val-的前驱"><a href="#查询-val-的前驱" class="headerlink" title="查询 val 的前驱"></a>查询 val 的前驱</h3><p>插入 $val$，在根的左子树中找最大的值（即一直向右子树寻找），最后删除 $val$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">val2pre</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(val);</span><br><span class="line">    splay_tree *x=root-&gt;son[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;son[<span class="number">1</span>]!=t) &#123;</span><br><span class="line">        x=x-&gt;son[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=x-&gt;val;</span><br><span class="line">    <span class="built_in">del</span>(val);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-val-的后继"><a href="#查询-val-的后继" class="headerlink" title="查询 val 的后继"></a>查询 val 的后继</h3><p>同查询前驱类似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">val2suc</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(val);</span><br><span class="line">    splay_tree *x=root-&gt;son[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;son[<span class="number">0</span>]!=t) &#123;</span><br><span class="line">        x=x-&gt;son[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=x-&gt;val;</span><br><span class="line">    <span class="built_in">del</span>(val);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><blockquote>
<p>本文部分参考 <a href="https://oi-wiki.org/ds/splay">Splay - OI Wiki</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>study</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/08/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>今日暴走</title>
    <url>/2025/08/03/%E4%BB%8A%E6%97%A5%E6%9A%B4%E8%B5%B0/</url>
    <content><![CDATA[<p>今天优化网页的过程，简直是把自己扔进了代码的泥沼里挣扎。<br><img src="https://s1.aigei.com/src/img/gif/02/021da8d3e9e24928b36cd0e6a5ddb567.gif?imageMogr2/auto-orient/thumbnail/!282x226r/gravity/Center/crop/282x226/quality/85/%7CimageView2/2/w/282&e=2051020800&token=P7S2Xpzfz11vAkASLTkfHN7Fw-oOZBecqeJaxypL:t6dvivz7_aMOjctuQUsuUfUxZEw=" alt="红温"></p>
<span id="more"></span>

<p>下午打开项目时还信心满满，想着把加载速度提一提就行，结果点开控制台的瞬间就傻了 —— 红得刺眼的报错信息滚了三屏，像是在嘲笑我昨晚的天真。原以为只是压缩几个图片的事，没想到牵出了一串连锁反应：压缩完的图片在 IE 上全成了裂图，回滚版本时又误删了上周写的适配逻辑，等找回备份时，两个小时已经耗在原地。<br>最崩溃的是改评论区那块。明明跟着教程一步不差地配置，可 Giscus 要么加载不出来，要么一刷新就跳 404。对着文档翻到第 17 页，手指在键盘上敲到发麻，连 API 地址都快背下来了，屏幕上的 “分类不存在” 提示却像块胶布似的撕不掉。中间有三次想把鼠标摔了，盯着屏幕里那个顽固的空白区域，突然觉得眼睛发酸 —— 明明上周还好好的，怎么今天连一行代码都跟我作对？<br>傍晚时总算把加载速度压到了 1 秒内，可移动端的导航栏又开始抽风：在安卓上好好的，到了 iOS 就缩成一团；调成横屏模式，整个菜单直接钻进了页脚。对着开发者工具里密密麻麻的样式继承链，突然没力气骂娘了，就坐在那儿盯着光标闪，连外卖凉了都没察觉。<br>现在页面总算能看了，可盯着那个勉强能跑的版本，一点成就感都没有。后背僵得像块木板，手腕贴的膏药硌得慌，再看代码时眼睛里全是重影。原来优化网页哪是什么升级打怪，根本就是拿着镊子在乱麻里找线头，找着找着，连自己都快成了那团乱麻里的一根。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>Note</tag>
        <tag>观测</tag>
      </tags>
  </entry>
  <entry>
    <title>劇終</title>
    <url>/2025/08/03/%E5%8A%87%E7%B5%82/</url>
    <content><![CDATA[<p><img src="http://img.xinmin.cn/xmwb/2020/5/NEM1_20200510_C0325256459_A2250577.png" alt="剧终"></p>
]]></content>
      <categories>
        <category>talk，追剧</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>劇終-2</title>
    <url>/2025/08/08/%E5%8A%87%E7%B5%822/</url>
    <content><![CDATA[<p><img src="http://mms2.baidu.com/it/u=3117035648,2825770514&fm=253&app=138&f=JPEG?w=652&h=500" alt="剧终"></p>
]]></content>
      <categories>
        <category>talk，追剧</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>序列自动机学习笔记</title>
    <url>/2025/08/03/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>序列自动机是接受一个字符串的子序列的自动机。</p>
<p>它可以方便地维护 &#x2F; 匹配字符串（数列）的所有子序列。</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设我们要维护的字符串为 $S$，它的字符集大小为 $siz$。</p>
<p>有两种构建序列自动机的方式：</p>
<ol>
<li><p>构建所有子序列的复杂度为 $O(\mid S\mid\cdot siz)$，查询<strong>所有</strong>子序列的复杂度即为所有子序列的个数；</p>
</li>
<li><p>构建复杂度 $O(n)$，查询<strong>一个</strong>子序列 $T$ 的复杂度为 $O(\mid T\mid\log\mid S\mid)$。</p>
</li>
</ol>
<p>两种实现方式的思想都是维护数组 $nex_{i,c}$，表示 $i+1$ 至 $n$ 中第一次出现字符 $c$ 的位置。</p>
<h2 id="第一种-实现"><a href="#第一种-实现" class="headerlink" title="第一种 - 实现"></a>第一种 - 实现</h2><p><a href="https://loj.ac/problem/2172">例题</a></p>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>对于 $X,Y$ 序列，我们分别建一个序列自动机。</p>
<p>从后往前扫，每次将 $nex_i$ 复制到 $nex_{i-1}$，再把 $nex_{i-1,S_i}$ 更新为 $i$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> s[],<span class="type">int</span> nex[][SIZ])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i;--i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(nex[i<span class="number">-1</span>],nex[i],<span class="built_in">sizeof</span>(nex[i]));</span><br><span class="line">        nex[i<span class="number">-1</span>][s[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>使用 dfs 并维护一个栈，访问节点时的栈即为该子序列。</p>
<p>依次访问每个字符指向的节点，访问时将字符加入栈，退出时再将栈顶弹出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Output/Use stk[]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i=<span class="number">0</span>;i&lt;SIZ;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nex[x][i]) &#123;</span><br><span class="line">            stk[++top]=i;</span><br><span class="line">            <span class="built_in">dfs</span>(nex[x][i]);</span><br><span class="line">            stk[top--]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这例题竟然要高精度！:angry:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3010</span>,C=<span class="number">26</span>,S=C&lt;&lt;<span class="number">1</span>,D=<span class="number">20</span>,M=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m,n,k,a[N<span class="number">+1</span>],b[N<span class="number">+1</span>],nexa[N<span class="number">+1</span>][S],nexb[N<span class="number">+1</span>][S],top;</span><br><span class="line"><span class="type">char</span> x[N<span class="number">+2</span>],y[N<span class="number">+2</span>],res[N<span class="number">+2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">number</span> &#123;</span><br><span class="line">    <span class="type">int</span> dig;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *s;</span><br><span class="line">    <span class="type">bool</span> vis;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dig=<span class="number">0</span>,vis=<span class="literal">true</span>;</span><br><span class="line">        s=<span class="keyword">new</span> <span class="type">long</span> <span class="type">long</span>[D];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i) &#123;</span><br><span class="line">            s[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val) &#123;</span><br><span class="line">            s[<span class="number">0</span>]=val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> number ano)</span><br><span class="line">    &#123;</span><br><span class="line">        dig=<span class="built_in">max</span>(dig,ano.dig)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=dig;++i) &#123;</span><br><span class="line">            s[i]+=ano.s[i];</span><br><span class="line">            s[i<span class="number">+1</span>]+=s[i]/M,s[i]%=M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(dig&amp;&amp;!s[dig]) &#123;</span><br><span class="line">            --dig;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">number f[N<span class="number">+1</span>][N<span class="number">+1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x[],<span class="type">int</span> nex[][S])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;--i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(nex[i<span class="number">-1</span>],nex[i],<span class="built_in">sizeof</span>(nex[i]));</span><br><span class="line">        nex[i<span class="number">-1</span>][x[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(res<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nexa[x][i]&amp;&amp;nexb[y][i]) &#123;</span><br><span class="line">            res[++top]=i&lt;C?i+<span class="string">&#x27;A&#x27;</span>:i+<span class="string">&#x27;a&#x27;</span><span class="number">-26</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(nexa[x][i],nexb[y][i]);</span><br><span class="line">            res[top--]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y].vis) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y].<span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nexa[x][i]&amp;&amp;nexb[y][i]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(nexa[x][i],nexb[y][i]);</span><br><span class="line">            f[x][y]+=f[nexa[x][i]][nexb[y][i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(number x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x.s[x.dig]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x.dig<span class="number">-1</span>;~i;--i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%09lld&quot;</span>,x.s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,x<span class="number">+1</span>,y<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">        a[i]=<span class="built_in">isupper</span>(x[i])?x[i]-<span class="string">&#x27;A&#x27;</span>:x[i]-<span class="string">&#x27;a&#x27;</span><span class="number">+26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        b[i]=<span class="built_in">isupper</span>(y[i])?y[i]-<span class="string">&#x27;A&#x27;</span>:y[i]-<span class="string">&#x27;a&#x27;</span><span class="number">+26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(m,a,nexa);</span><br><span class="line">    <span class="built_in">build</span>(n,b,nexb);</span><br><span class="line">    <span class="keyword">if</span>(k) &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">print</span>(f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二种-实现"><a href="#第二种-实现" class="headerlink" title="第二种 - 实现"></a>第二种 - 实现</h2><p><a href="https://www.luogu.com.cn/problem/P5826">例题</a></p>
<h3 id="建立-1"><a href="#建立-1" class="headerlink" title="建立"></a>建立</h3><p>这种方式的建立十分简单。</p>
<p>用 <code>vector</code> 维护哪些位置上出现了某个字符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> s[],vector&lt;<span class="type">int</span>&gt;pos[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        pos[s[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>假设当前查询到 $T_i$，且 $T_{i-1}$ 位于 $S$ 的第 $las$ 位。</p>
<p>显然我们要在 $T_i$ 的 <code>vector</code> 数组里找到一个 $&gt;las$ 的位置，选择它作为 $T_i$。</p>
<p>如果有多个点符合，那要选哪个点呢？</p>
<p>我们贪心选取最前面的一个点就可以了，因为：如果选后面的可以，改成选前面的显然也可以；如果选前面的不行，那么选后面的会跳过更多也许有用的结点。</p>
<p>二分一下，即可<del>钦定</del>找出最前的满足答案的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> len,<span class="type">char</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p=<span class="built_in">upper_bound</span>(pos[t[i]].<span class="built_in">begin</span>(),pos[t[i]].<span class="built_in">end</span>(),las);</span><br><span class="line">        <span class="keyword">if</span>(p==pos[t[i]].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        las=*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>,M=<span class="number">1e5</span>,L=<span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> n,q,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;pos[M<span class="number">+1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(),n=<span class="built_in">read</span>(),q=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        pos[<span class="built_in">read</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="type">bool</span> res=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> las=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">read</span>();</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> val[L<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;++i) &#123;</span><br><span class="line">            val[i]=<span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p=<span class="built_in">upper_bound</span>(pos[val[i]].<span class="built_in">begin</span>(),pos[val[i]].<span class="built_in">end</span>(),las);</span><br><span class="line">            <span class="keyword">if</span>(p==pos[val[i]].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            las=*p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(res?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><blockquote>
<p>序列自动机第二种部分参考<a href="https://www.luogu.com.cn/blog/WYXkk/zi-xu-lie-zi-dong-ji">浅谈子序列自动机 - WYXkk 的博客</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>study</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化平衡树学习笔记</title>
    <url>/2025/08/03/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FHQ Treap，又叫无旋 Treap，是一种平衡树，还可以支持可持久化，<del>代码也通俗易懂</del>。</p>
<p><a href="https://www.luogu.com.cn/problem/P3835">例题</a></p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每个节点需保存它所维护的值 $val$，它的子树大小 $siz$，父节点 $fa$ 以及它的左儿子 $lson$ 和右儿子 $rson$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> val,pri,siz;</span><br><span class="line">    tree *lson,*rson;</span><br><span class="line">&#125;;</span><br><span class="line">tree nul&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,&amp;nul,&amp;nul&#125;,*root[N<span class="number">+1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="建立新节点"><a href="#建立新节点" class="headerlink" title="建立新节点"></a>建立新节点</h3><p>像 Treap 一样赋予随机值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> tree *<span class="title">new_tree</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *x=<span class="keyword">new</span> tree;</span><br><span class="line">    *x=tree&#123;val,<span class="built_in">rand</span>(),<span class="number">1</span>,&amp;nul,&amp;nul&#125;;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> tree *<span class="title">copy</span><span class="params">(tree *ori)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *x=<span class="keyword">new</span> tree;</span><br><span class="line">    *x=*ori;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新节点-siz"><a href="#更新节点-siz" class="headerlink" title="更新节点 siz"></a>更新节点 siz</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x-&gt;siz=x-&gt;lson-&gt;siz+x-&gt;rson-&gt;siz<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>合并 $x$ 和 $y$。（保证 $x$ 的权值 $\leq y$ 的权值）</p>
<p>如果两个节点中有空节点，则返回非空节点。</p>
<p>根据 Treap 的堆性质，选择随机值较大的点（假设是 $x$），合并它的右儿子（如果是 $y$ 则为它的左儿子）与 $y$。</p>
<p>由于需要可持久化，需要重建 $x$ 节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tree *<span class="title">merge</span><span class="params">(tree *x,tree *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x==&amp;nul)||(y==&amp;nul)) &#123;</span><br><span class="line">        <span class="keyword">return</span> x==&amp;nul?y:x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;pri&lt;=y-&gt;pri) &#123;</span><br><span class="line">        y=<span class="built_in">copy</span>(y);</span><br><span class="line">        y-&gt;lson=<span class="built_in">merge</span>(x,y-&gt;lson);</span><br><span class="line">        <span class="built_in">push_up</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x=<span class="built_in">copy</span>(x);</span><br><span class="line">        x-&gt;rson=<span class="built_in">merge</span>(x-&gt;rson,y);</span><br><span class="line">        <span class="built_in">push_up</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h3><p>将 $x$ 分成权值 $\leq val$ 的树和权值 $&gt;val$ 的树。</p>
<p>如果 $x$ 的权值 $\leq val$，则把 $x$ 的右儿子分裂，否则分裂左儿子。</p>
<p>注意可持久化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(tree *x,<span class="type">int</span> val,tree *&amp;l,tree *&amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==&amp;nul) &#123;</span><br><span class="line">        l=r=&amp;nul;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;val&lt;=val) &#123;</span><br><span class="line">        l=<span class="built_in">copy</span>(x);</span><br><span class="line">        <span class="built_in">split</span>(l-&gt;rson,val,l-&gt;rson,r);</span><br><span class="line">        <span class="built_in">push_up</span>(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r=<span class="built_in">copy</span>(x);</span><br><span class="line">        <span class="built_in">split</span>(r-&gt;lson,val,l,r-&gt;lson);</span><br><span class="line">        <span class="built_in">push_up</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入值"><a href="#插入值" class="headerlink" title="插入值"></a>插入值</h3><p>将 $root$ 分裂成分成权值 $\leq val$ 的树 $l$ 与权值 $&gt;val$ 的树 $r$。</p>
<p>新建一个值为 $val$ 的节点（设为 $x$）。</p>
<p>依次合并 $l,x,r$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(tree *&amp;root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *l,*r;</span><br><span class="line">    <span class="built_in">split</span>(root,val,l,r);</span><br><span class="line">    tree *x=<span class="built_in">new_tree</span>(val);</span><br><span class="line">    root=<span class="built_in">merge</span>(l,<span class="built_in">merge</span>(x,r));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除值"><a href="#删除值" class="headerlink" title="删除值"></a>删除值</h3><p>将 $root$ 分裂成分成权值 $&lt;val$ 的树 $l$、权值 $&#x3D;val$ 的树 $mid$ 与权值 $&gt;val$ 的树 $r$。</p>
<p>依次合并 $l,lson_{mid},rson_{mid},r$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(tree *&amp;root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *l,*l_mid,*mid,*r;</span><br><span class="line">    <span class="built_in">split</span>(root,val,l_mid,r);</span><br><span class="line">    <span class="built_in">split</span>(l_mid,val<span class="number">-1</span>,l,mid);</span><br><span class="line">    root=<span class="built_in">merge</span>(l,<span class="built_in">merge</span>(<span class="built_in">merge</span>(mid-&gt;lson,mid-&gt;rson),r));</span><br><span class="line">    <span class="keyword">if</span>(mid!=&amp;nul) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询排名为-rnk-的数"><a href="#查询排名为-rnk-的数" class="headerlink" title="查询排名为 rnk 的数"></a>查询排名为 rnk 的数</h3><ul>
<li><p>如果 $rnk$ 小于等于当前节点左子树的 $siz$，则递归左子树；</p>
</li>
<li><p>否则将 $rnk$ 减去左子树的 $siz+1$，如果 $rnk\leq0$，则返回当前节点的权值，否则递归右子树。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnk2val</span><span class="params">(tree *x,<span class="type">int</span> rnk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rnk&lt;=x-&gt;lson-&gt;siz) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rnk2val</span>(x-&gt;lson,rnk);</span><br><span class="line">    &#125;</span><br><span class="line">    rnk-=x-&gt;lson-&gt;siz<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span> rnk?<span class="built_in">rnk2val</span>(x-&gt;rson,rnk):x-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-val-的排名"><a href="#查询-val-的排名" class="headerlink" title="查询 val 的排名"></a>查询 val 的排名</h3><p>把 $root$ 分裂为权值 $&lt;val$ 的树 $l$ 与权值 $\geq val$ 的树 $r$。</p>
<p>统计 $siz_l+1$ 即为答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">val2rnk</span><span class="params">(tree *&amp;root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *l,*mid_r;</span><br><span class="line">    <span class="built_in">split</span>(root,val<span class="number">-1</span>,l,mid_r);</span><br><span class="line">    <span class="type">int</span> ret=l-&gt;siz<span class="number">+1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(l,mid_r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-val-的前驱"><a href="#查询-val-的前驱" class="headerlink" title="查询 val 的前驱"></a>查询 val 的前驱</h3><p>把 $root$ 分裂为权值 $&lt;val$ 的树 $l$ 与权值 $\geq val$ 的树 $r$。</p>
<p>查询 $l$ 中排名为 $siz_l$ 的数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">val2pre</span><span class="params">(tree *&amp;root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *l,*r;</span><br><span class="line">    <span class="built_in">split</span>(root,val<span class="number">-1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l==&amp;nul) &#123;</span><br><span class="line">        <span class="keyword">return</span> -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">rnk2val</span>(l,l-&gt;siz);</span><br><span class="line">    root=<span class="built_in">merge</span>(l,r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询-val-的后继"><a href="#查询-val-的后继" class="headerlink" title="查询 val 的后继"></a>查询 val 的后继</h3><p>把 $root$ 分裂为权值 $\leq val$ 的树 $l$ 与权值 $&gt;val$ 的树 $r$。</p>
<p>查询 $r$ 中最小的（排名为 $1$）的数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">val2suc</span><span class="params">(tree *&amp;root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *l,*r;</span><br><span class="line">    <span class="built_in">split</span>(root,val,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r==&amp;nul) &#123;</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">rnk2val</span>(r,<span class="number">1</span>);</span><br><span class="line">    root=<span class="built_in">merge</span>(l,r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>study</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇Blog</title>
    <url>/2025/08/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>看着浏览器里加载完成的页面，指尖悬在鼠标上迟迟没敢点击刷新 —— 这个承载了三周夜晚的博客，终于以完整的姿态躺在屏幕里了。​<br>最初只是想找个地方堆放碎片化的思考，却在搭建时跌进了无数个细节的漩涡。为了让代码块的高亮配色更顺眼，对着十六进制色值调试到爆炸；给侧边栏加卡片阴影时，反复调整box-shadow的参数直到光影恰好落在文字边缘；甚至为了让 “发表于” 三个字的颜色和正文形成微妙呼应，对着开发者工具的色板试了二十种灰度。​<br>那些被YAML语法错误逼到挠头的夜晚，那些在GitHub Pages部署失败时的茫然，此刻都成了页面里跳动的像素。当最后一次执行hexo d，看着终端里滚动的部署日志变成绿色的 “Deploy done”，突然明白比起 “拥有一个博客”，更珍贵的是亲手打磨细节的过程。​<br>这不是一个完美的作品，代码里还留着调试时的注释，背景图的蒙版透明度或许还能再优化 5%。但它像一间亲手粉刷的小房间，每一处不完美都藏着专属的温度 —— 那个歪歪扭扭的 “一言” 模块，是第一次调用 API 时的笨拙见证；侧边栏里略大于标准尺寸的头像框，藏着反复调整时的固执。​<br>往后大概会在这里写技术笔记，也会随手记下某个黄昏的胡思乱想。毕竟，比起搭建完成的瞬间，更让人期待的是，这个由代码和热爱筑成的小空间，会慢慢生长出怎样的内容。​<br>现在，是时候按下发布键，让它在互联网的角落里，开始自己的故事了。​</p>
<p>特别感谢：LCX（Thank you for your support）</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>线性尺寸莫比乌斯函数</title>
    <url>/2025/08/03/%E7%BA%BF%E6%80%A7%E5%B0%BA%E5%AF%B8%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>模拟赛中的一道题，让我发现自己莫比乌斯函数的基础十分薄弱。:cry:</p>
<span id="more"></span>

<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>先来看看莫比乌斯函数的定义：</p>
<p>设 $n&#x3D;\prod_{i&#x3D;1}^Np_i^{k_i}$（$p$ 为质数集合），则</p>
<p>$$<br>\mu(n)&#x3D;<br>\begin{cases}<br>1&amp;n&#x3D;1\<br>(-1)^N&amp;\forall1\leq i\leq N,k_i&#x3D;1\<br>0&amp;k_i&gt;1<br>\end{cases}<br>$$</p>
<p>当 $i\in p$ 时，显然 $\mu(i)&#x3D;-1$。</p>
<p>设 $n^\prime&#x3D;\frac n{p_1}$，在线性筛中，$n$ 通过 $n^\prime\cdot p_1$ 被筛去。</p>
<p>当 $n^\prime\mid p_1$，即 $k_1&gt;1$ 时，$\mu(n)&#x3D;0$；</p>
<p>否则 $n^\prime$ 有 $N-1$ 个质因子。</p>
<p>如果 $\mu(n^\prime)\neq0$，即 $\forall2\leq i\leq N,k_i&#x3D;1$ 时，根据定义得：</p>
<p>$$<br>\begin{aligned}\mu(n)&amp;&#x3D;(-1)^N\&amp;&#x3D;(-1)^{N-1}\cdot(-1)\&amp;&#x3D;\mu(n^\prime)\cdot(-1)\&amp;&#x3D;-\mu(n^\prime)\end{aligned}<br>$$</p>
<p>如果 $\mu(n^\prime)&#x3D;0$，则 $n^\prime$ 一定有次数大于 $1$ 的质因子，所以 $n$ 也一定有，即 $\mu(n)&#x3D;0$。</p>
<p>此时 $\mu(n)&#x3D;-\mu(n^\prime)$ 仍成立。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!npri[i]) &#123;</span><br><span class="line">        pri[++cnt]=i;</span><br><span class="line">        mu[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,tem;(j&lt;=cnt)&amp;&amp;((tem=i*pri[j])&lt;=N);++j) &#123;</span><br><span class="line">        npri[tem]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        mu[tem]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><blockquote>
<p>本文部分参考<a href="https://oi.men.ci/euler-sieve/">线性筛法筛素数、莫比乌斯函数、欧拉函数 | Menci’s Blog</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>study</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>线性求逆元</title>
    <url>/2025/08/03/%E7%BA%BF%E6%80%A7%E6%B1%82%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>当要求 $1-n$ 中所有数的逆元时，$O(n\log p)$ 的方法就有点悬了。</p>
<p>下面介绍一种 $O(n)$ 求逆元的好方法。</p>
<span id="more"></span>

<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>首先，$1^{-1}\equiv1\pmod p$。</p>
<p>设 $k&#x3D;\lfloor\frac pi\rfloor$，则 $p&#x3D;k\cdot i+r$，其中 $r&#x3D;p\bmod i,1&lt;i&lt;p$。</p>
<p>易得 $k\cdot i+r\equiv0\pmod p$。</p>
<p>两边同乘 $i^{-1}\cdot r^{-1}$ 得：</p>
<p>$$<br>\begin{aligned}<br>k\cdot r^{-1}+i^{-1}&amp;\equiv0&amp;\pmod p\<br>i^{-1}&amp;\equiv-k\cdot r^{-1}&amp;\pmod p\<br>i^{-1}&amp;\equiv-\lfloor\frac pi\rfloor\cdot(p\bmod i)^{-1}&amp;\pmod p<br>\end{aligned}<br>$$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) &#123;</span><br><span class="line">    inv[i]=-(mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为使 $inv_i$ 非负，代码也可写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) &#123;</span><br><span class="line">    inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>study</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆体的建设与总结</title>
    <url>/2025/08/19/%E8%AE%B0%E5%BF%86%E4%BD%93/</url>
    <content><![CDATA[<h1 id="记忆体的建设与总结"><a href="#记忆体的建设与总结" class="headerlink" title="记忆体的建设与总结"></a>记忆体的建设与总结</h1><p>具有记忆衰退功能的电子生命体（Python 实现）</p>
<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><p>本文档提供一个简化版「记忆衰退电子生命体」的 Python 实现，核心模拟人类记忆的三大特性：<br>短期记忆易遗忘：临时信息（如待办事项）衰退速度远快于长期记忆。<br>长期记忆随时间模糊：基于艾宾浩斯遗忘曲线，记忆保留率随时间呈指数衰减。<br>复习增强记忆：提取（复习）记忆时，会提升其活跃度，降低遗忘速度。</p>
<h2 id="2-完整代码实现"><a href="#2-完整代码实现" class="headerlink" title="2. 完整代码实现"></a>2. 完整代码实现</h2><h3 id="2-1-核心模块：记忆系统类"><a href="#2-1-核心模块：记忆系统类" class="headerlink" title="2.1 核心模块：记忆系统类"></a>2.1 核心模块：记忆系统类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">from dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line">from typing <span class="keyword">import</span> Dict, List, Optional</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span>:</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;记忆单元数据结构&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    content: str          # 记忆具体内容</span><br><span class="line">    timestamp: <span class="type">float</span>      # 记忆存储时间（时间戳）</span><br><span class="line">    active_level: <span class="type">float</span>   # 活跃度（<span class="number">0</span><span class="number">-1</span>，越高越难遗忘）</span><br><span class="line">    stability: <span class="type">float</span>      # 稳定性（<span class="number">0.5</span><span class="number">-2.0</span>，基础遗忘抵抗能力）</span><br><span class="line">    is_short_term: <span class="type">bool</span>   # 是否为短期记忆（衰退更快）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBeing</span>:</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;具有记忆衰退功能的电子生命体类&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    def __init__(self, name: str):</span><br><span class="line">        self.name = name                          # 电子生命体名称</span><br><span class="line">        self.memories: Dict[str, Memory] = &#123;&#125;     # 记忆库（key: 记忆唯一标识）</span><br><span class="line">        self.current_time = time.<span class="built_in">time</span>()           # 系统当前时间（用于模拟时间流逝）</span><br><span class="line"></span><br><span class="line">    def _get_time_since_creation(self, memory: Memory) -&gt; <span class="type">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;计算记忆从存储到当前的时间间隔（秒）&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.current_time - memory.timestamp</span><br><span class="line"></span><br><span class="line">    def _forget_curve(self, memory: Memory) -&gt; <span class="type">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        基于艾宾浩斯遗忘曲线的记忆保留率计算</span></span><br><span class="line"><span class="string">        公式：保留率 = e^(-t/(S*A*K)) </span></span><br><span class="line"><span class="string">        - t: 时间间隔（秒）</span></span><br><span class="line"><span class="string">        - S: 记忆稳定性</span></span><br><span class="line"><span class="string">        - A: 记忆活跃度</span></span><br><span class="line"><span class="string">        - K: 短期记忆系数（0.3，加速衰退）</span></span><br><span class="line"><span class="string">        返回值范围：0.0（完全遗忘）~ 1.0（完全清晰）</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        time_diff = self._get_time_since_creation(memory)</span><br><span class="line">        <span class="keyword">if</span> time_diff &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>  # 避免时间异常导致的计算错误</span><br><span class="line">        </span><br><span class="line">        # 短期记忆衰退速度为长期记忆的 ~<span class="number">3</span> 倍</span><br><span class="line">        short_term_coeff = <span class="number">0.3</span> <span class="keyword">if</span> memory.is_short_term <span class="keyword">else</span> <span class="number">1.0</span></span><br><span class="line">        denominator = memory.stability * memory.active_level * short_term_coeff</span><br><span class="line">        </span><br><span class="line">        # 防止分母过小导致保留率骤降</span><br><span class="line">        denominator = <span class="built_in">max</span>(<span class="number">0.1</span>, denominator)</span><br><span class="line">        </span><br><span class="line">        retention_rate = math.<span class="built_in">exp</span>(-time_diff / denominator)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">min</span>(<span class="number">1.0</span>, retention_rate))  # 限制返回值范围</span><br><span class="line"></span><br><span class="line">    def <span class="built_in">store_memory</span>(self, </span><br><span class="line">                    key: str, </span><br><span class="line">                    content: str, </span><br><span class="line">                    is_short_term: <span class="type">bool</span> = False, </span><br><span class="line">                    active_level: <span class="type">float</span> = <span class="number">0.7</span>, </span><br><span class="line">                    stability: <span class="type">float</span> = <span class="number">1.0</span>) -&gt; None:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        存储记忆到记忆库</span></span><br><span class="line"><span class="string">        :param key: 记忆唯一标识（用于后续提取）</span></span><br><span class="line"><span class="string">        :param content: 记忆内容</span></span><br><span class="line"><span class="string">        :param is_short_term: 是否为短期记忆</span></span><br><span class="line"><span class="string">        :param active_level: 初始活跃度（0.1-1.0）</span></span><br><span class="line"><span class="string">        :param stability: 初始稳定性（0.5-2.0）</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        # 修正参数范围，避免异常值</span><br><span class="line">        active_level = <span class="built_in">max</span>(<span class="number">0.1</span>, <span class="built_in">min</span>(<span class="number">1.0</span>, active_level))</span><br><span class="line">        stability = <span class="built_in">max</span>(<span class="number">0.5</span>, <span class="built_in">min</span>(<span class="number">2.0</span>, stability))</span><br><span class="line">        </span><br><span class="line">        self.memories[key] = <span class="built_in">Memory</span>(</span><br><span class="line">            content=content,</span><br><span class="line">            timestamp=self.current_time,</span><br><span class="line">            active_level=active_level,</span><br><span class="line">            stability=stability,</span><br><span class="line">            is_short_term=is_short_term</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;[&#123;self.name&#125;] 已存储记忆 | 内容：&#123;content&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    def _blur_memory(self, content: str, retention_rate: <span class="type">float</span>) -&gt; str:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        模拟记忆模糊效果</span></span><br><span class="line"><span class="string">        :param content: 原始记忆内容</span></span><br><span class="line"><span class="string">        :param retention_rate: 记忆保留率（0.0-1.0）</span></span><br><span class="line"><span class="string">        :return: 模糊后的记忆内容</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        # 保留率越高，模糊程度越低</span><br><span class="line">        keep_length = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="built_in">len</span>(content) * retention_rate * <span class="number">1.2</span>))</span><br><span class="line">        content_chars = <span class="built_in">list</span>(content)</span><br><span class="line">        </span><br><span class="line">        # 随机打乱并保留部分字符（模拟片段化记忆）</span><br><span class="line">        random.<span class="built_in">shuffle</span>(content_chars)</span><br><span class="line">        blurred_content = <span class="string">&#x27;&#x27;.join(content_chars[:keep_length])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 补充模糊标记，增强拟人感</span></span><br><span class="line"><span class="string">        if len(blurred_content) &lt; len(content):</span></span><br><span class="line"><span class="string">            return f&quot;...&#123;blurred_content&#125;...&quot;</span></span><br><span class="line"><span class="string">        return blurred_content</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def retrieve_memory(self, key: str) -&gt; Optional[str]:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        提取记忆（可能模糊或完全遗忘）</span></span><br><span class="line"><span class="string">        :param key: 记忆唯一标识</span></span><br><span class="line"><span class="string">        :return: 提取到的记忆（模糊/清晰）或 None（完全遗忘）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        # 记忆不存在（已遗忘或未存储）</span></span><br><span class="line"><span class="string">        if key not in self.memories:</span></span><br><span class="line"><span class="string">            print(f&quot;[&#123;self.name&#125;] 完全不记得这个内容了...&quot;)</span></span><br><span class="line"><span class="string">            return None</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        target_memory = self.memories[key]</span></span><br><span class="line"><span class="string">        retention_rate = self._forget_curve(target_memory)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 1. 保留率 &lt; 20%：完全遗忘，从记忆库删除</span></span><br><span class="line"><span class="string">        if retention_rate &lt; 0.2:</span></span><br><span class="line"><span class="string">            del self.memories[key]</span></span><br><span class="line"><span class="string">            print(f&quot;[&#123;self.name&#125;] 彻底忘记这个内容了...&quot;)</span></span><br><span class="line"><span class="string">            return None</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 2. 20% ≤ 保留率 &lt; 50%：部分遗忘，内容模糊</span></span><br><span class="line"><span class="string">        elif 0.2 &lt;= retention_rate &lt; 0.5:</span></span><br><span class="line"><span class="string">            blurred_content = self._blur_memory(target_memory.content, retention_rate)</span></span><br><span class="line"><span class="string">            print(f&quot;[&#123;self.name&#125;] 隐约记得：&#123;blurred_content&#125;&quot;)</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            # 复习机制：提取后提升活跃度（减缓后续遗忘）</span></span><br><span class="line"><span class="string">            target_memory.active_level = min(1.0, target_memory.active_level + 0.1)</span></span><br><span class="line"><span class="string">            return blurred_content</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 3. 保留率 ≥ 50%：记忆基本清晰</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            print(f&quot;[&#123;self.name&#125;] 清晰记得：&#123;target_memory.content&#125;&quot;)</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            # 复习机制：提取后轻微提升活跃度</span></span><br><span class="line"><span class="string">            target_memory.active_level = min(1.0, target_memory.active_level + 0.05)</span></span><br><span class="line"><span class="string">            return target_memory.content</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def simulate_time_pass(self, seconds: float) -&gt; None:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        模拟时间流逝（触发记忆自然衰退）</span></span><br><span class="line"><span class="string">        :param seconds: 流逝的时间（秒）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        self.current_time += seconds</span></span><br><span class="line"><span class="string">        print(f&quot;\n=== [&#123;self.name&#125;] 时间流逝 &#123;seconds&#125; 秒 ===&quot;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 主动检查并清理已完全遗忘的记忆</span></span><br><span class="line"><span class="string">        self._clean_forgotten_memories()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def _clean_forgotten_memories(self) -&gt; None:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;批量清理记忆库中已完全遗忘的记忆（保留率 &lt; 20%）&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        forgotten_keys = []</span></span><br><span class="line"><span class="string">        for key, memory in self.memories.items():</span></span><br><span class="line"><span class="string">            if self._forget_curve(memory) &lt; 0.2:</span></span><br><span class="line"><span class="string">                forgotten_keys.append(key)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 删除完全遗忘的记忆</span></span><br><span class="line"><span class="string">        for key in forgotten_keys:</span></span><br><span class="line"><span class="string">            del self.memories[key]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        if forgotten_keys:</span></span><br><span class="line"><span class="string">            print(f&quot;[&#123;self.name&#125;] 有些记忆已经彻底模糊，无法回忆...&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-演示模块：交互场景测试"><a href="#2-2-演示模块：交互场景测试" class="headerlink" title="2.2 演示模块：交互场景测试"></a>2.2 演示模块：交互场景测试</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">demo_memory_being</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    <span class="string">&quot;&quot;</span><span class="string">&quot;演示电子生命体的记忆存储、提取和衰退过程&quot;</span><span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="function">    # <span class="number">1.</span> 创建电子生命体（命名为“星尘”）</span></span><br><span class="line"><span class="function">    stardust =</span> <span class="built_in">MemoryBeing</span>(name=<span class="string">&quot;星尘&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&quot;\n=== 初始化电子生命体：&#123;stardust.name&#125; ===&quot;</span>)</span><br><span class="line"></span><br><span class="line">    # <span class="number">2.</span> 存储三类不同记忆</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 第一步：存储记忆 ===&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">store_memory</span>(</span><br><span class="line">        key=<span class="string">&quot;user_name&quot;</span>,</span><br><span class="line">        content=<span class="string">&quot;用户的名字是小明&quot;</span>,</span><br><span class="line">        is_short_term=False,  # 长期记忆（重要信息）</span><br><span class="line">        stability=<span class="number">1.8</span>,        # 高稳定性（难遗忘）</span><br><span class="line">        active_level=<span class="number">0.8</span>      # 高活跃度</span><br><span class="line">    )</span><br><span class="line">    stardust.<span class="built_in">store_memory</span>(</span><br><span class="line">        key=<span class="string">&quot;temp_task&quot;</span>,</span><br><span class="line">        content=<span class="string">&quot;明天提醒用户带钥匙&quot;</span>,</span><br><span class="line">        is_short_term=True,   # 短期记忆（临时任务）</span><br><span class="line">        stability=<span class="number">0.6</span>,        # 低稳定性</span><br><span class="line">        active_level=<span class="number">0.5</span>      # 中活跃度</span><br><span class="line">    )</span><br><span class="line">    stardust.<span class="built_in">store_memory</span>(</span><br><span class="line">        key=<span class="string">&quot;favorite_song&quot;</span>,</span><br><span class="line">        content=<span class="string">&quot;用户最喜欢的歌是《月光》&quot;</span>,</span><br><span class="line">        is_short_term=False,  # 长期记忆</span><br><span class="line">        stability=<span class="number">1.2</span>,        # 中稳定性</span><br><span class="line">        active_level=<span class="number">0.9</span>      # 高活跃度（常提及）</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # <span class="number">3.</span> 立即提取记忆（刚存储，均清晰）</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 第二步：立即提取记忆 ===&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;user_name&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;temp_task&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;favorite_song&quot;</span>)</span><br><span class="line"></span><br><span class="line">    # <span class="number">4.</span> 模拟 <span class="number">1</span> 分钟后（短期记忆开始衰退）</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 第三步：模拟 1 分钟后 ===&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">simulate_time_pass</span>(seconds=<span class="number">60</span>)</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;user_name&quot;</span>)    # 长期记忆仍清晰</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;temp_task&quot;</span>)    # 短期记忆开始模糊</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;favorite_song&quot;</span>)# 长期高活跃度记忆清晰</span><br><span class="line"></span><br><span class="line">    # <span class="number">5.</span> 模拟 <span class="number">10</span> 分钟后（短期记忆可能完全遗忘）</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 第四步：模拟 10 分钟后 ===&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">simulate_time_pass</span>(seconds=<span class="number">600</span>)</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;user_name&quot;</span>)    # 长期记忆轻微模糊</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;temp_task&quot;</span>)    # 短期记忆完全遗忘</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;favorite_song&quot;</span>)# 长期高活跃度记忆仍清晰</span><br><span class="line"></span><br><span class="line">    # <span class="number">6.</span> 模拟 <span class="number">2</span> 小时后（长期记忆进一步衰退）</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 第五步：模拟 2 小时后 ===&quot;</span>)</span><br><span class="line">    stardust.<span class="built_in">simulate_time_pass</span>(seconds=<span class="number">7200</span>)</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;user_name&quot;</span>)    # 长期记忆明显模糊</span><br><span class="line">    stardust.<span class="built_in">retrieve_memory</span>(key=<span class="string">&quot;favorite_song&quot;</span>)# 长期高活跃度记忆轻微模糊</span><br></pre></td></tr></table></figure>

<h1 id="执行演示"><a href="#执行演示" class="headerlink" title="执行演示"></a>执行演示</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">demo_memory_being</span>()</span><br></pre></td></tr></table></figure>
<h2 id="3-代码核心逻辑说明"><a href="#3-代码核心逻辑说明" class="headerlink" title="3. 代码核心逻辑说明"></a>3. 代码核心逻辑说明</h2><h3 id="3-1-记忆单元（Memory-类）"><a href="#3-1-记忆单元（Memory-类）" class="headerlink" title="3.1 记忆单元（Memory 类）"></a>3.1 记忆单元（Memory 类）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">content	str	记忆的具体内容	任意字符串</span><br><span class="line">timestamp	<span class="type">float</span>	记忆存储时的时间戳（用于计算遗忘时间）	Unix 时间戳</span><br><span class="line">active_level	<span class="type">float</span>	活跃度（复习频率越高，值越大，越难遗忘）	<span class="number">0.1</span> ~ <span class="number">1.0</span></span><br><span class="line">stability	<span class="type">float</span>	稳定性（记忆重要性，值越大，基础抗遗忘性越强）	<span class="number">0.5</span> ~ <span class="number">2.0</span></span><br><span class="line">is_short_term	<span class="type">bool</span>	是否为短期记忆（短期记忆衰退速度更快）	True / False</span><br></pre></td></tr></table></figure>

<h3 id="3-2-遗忘曲线算法"><a href="#3-2-遗忘曲线算法" class="headerlink" title="3.2 遗忘曲线算法"></a>3.2 遗忘曲线算法</h3><p>核心公式参考艾宾浩斯遗忘曲线的指数衰减特性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">记忆保留率 = e^(-t/(S * A * K))</span><br><span class="line">t：记忆存储到当前的时间间隔（秒）</span><br><span class="line">S：记忆稳定性（stability）</span><br><span class="line">A：记忆活跃度（active_level）</span><br><span class="line">K：短期记忆系数（0.3，使短期记忆衰退速度提升～3 倍）</span><br></pre></td></tr></table></figure>

<h3 id="3-3-关键功能流程"><a href="#3-3-关键功能流程" class="headerlink" title="3.3 关键功能流程"></a>3.3 关键功能流程</h3><p>存储记忆：调用 store_memory()，参数校验后生成 Memory 对象存入记忆库。<br>提取记忆：调用 retrieve_memory()，通过遗忘曲线计算保留率，按保留率返回「清晰内容 &#x2F; 模糊内容 &#x2F; None」。<br>模拟时间流逝：调用 simulate_time_pass()，更新系统时间并清理完全遗忘的记忆。<br>复习增强：每次提取记忆时，轻微提升该记忆的活跃度，减缓后续遗忘速度。</p>
<h3 id="3-4-运行效果示例"><a href="#3-4-运行效果示例" class="headerlink" title="3.4 运行效果示例"></a>3.4 运行效果示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">=== 初始化电子生命体：星尘 ===</span><br><span class="line"></span><br><span class="line">=== 第一步：存储记忆 ===</span><br><span class="line">[星尘] 已存储记忆 | 内容：用户的名字是小明</span><br><span class="line">[星尘] 已存储记忆 | 内容：明天提醒用户带钥匙</span><br><span class="line">[星尘] 已存储记忆 | 内容：用户最喜欢的歌是《月光》</span><br><span class="line"></span><br><span class="line">=== 第二步：立即提取记忆 ===</span><br><span class="line">[星尘] 清晰记得：用户的名字是小明</span><br><span class="line">[星尘] 清晰记得：明天提醒用户带钥匙</span><br><span class="line">[星尘] 清晰记得：用户最喜欢的歌是《月光》</span><br><span class="line"></span><br><span class="line">=== [星尘] 时间流逝 <span class="number">60</span> 秒 ===</span><br><span class="line">[星尘] 有些记忆已经彻底模糊，无法回忆...</span><br><span class="line"></span><br><span class="line">=== 第三步：模拟 <span class="number">1</span> 分钟后 ===</span><br><span class="line">[星尘] 清晰记得：用户的名字是小明</span><br><span class="line">[星尘] 隐约记得：...天提醒带钥匙...</span><br><span class="line">[星尘] 清晰记得：用户最喜欢的歌是《月光》</span><br><span class="line"></span><br><span class="line">=== [星尘] 时间流逝 <span class="number">600</span> 秒 ===</span><br><span class="line">[星尘] 有些记忆已经彻底模糊，无法回忆...</span><br><span class="line"></span><br><span class="line">=== 第四步：模拟 <span class="number">10</span> 分钟后 ===</span><br><span class="line">[星尘] 隐约记得：...用户的名字明...</span><br><span class="line">[星尘] 彻底忘记这个内容了...</span><br><span class="line">[星尘] 清晰记得：用户最喜欢的歌是《月光》</span><br><span class="line"></span><br><span class="line">=== [星尘] 时间流逝 <span class="number">7200</span> 秒 ===</span><br><span class="line">[星尘] 有些记忆已经彻底模糊，无法回忆...</span><br><span class="line"></span><br><span class="line">=== 第五步：模拟 <span class="number">2</span> 小时后 ===</span><br><span class="line">[星尘] 隐约记得：...用户的字明...</span><br><span class="line">[星尘] 隐约记得：...喜欢的《月光》...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-5-扩展方向"><a href="#3-5-扩展方向" class="headerlink" title="3.5 扩展方向"></a>3.5 扩展方向</h3><p>增加情感因素：为记忆添加「情感权重」（如开心 &#x2F; 难过的记忆更难遗忘），修改遗忘曲线公式加入情感系数。<br>优化模糊算法：替换随机打乱字符的逻辑，改为基于语义的片段保留（如保留句子主干）。<br>持久化存储：使用 SQLite &#x2F; MongoDB 将记忆库持久化，避免程序重启后记忆丢失。<br>交互接口：集成 CLI 或 Web 接口，支持用户实时与电子生命体对话并存储交互记忆。</p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>建设</tag>
      </tags>
  </entry>
</search>
